#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]

//' Degree preserving rewiring process.
//'
//' @param targetNode Target node sequence.
//' @param index_s Index sequence of source nodes' out- and in-degree. 
//'   index_s and index_t bridge the source/target node's and the 
//'   joint degree distribution matrix joint_e.
//' @param index_t Index sequence of target nodes' out- and in-degree. 
//' @param nattempts Integer, number of rewiring attempts.
//' @param joint_e Matrix, target joint distribution generated by
//'   wdnet::joint_dist().
//' @return Target node sequence and number of 
//'   accepted rewiring attempts.
//'
// [[Rcpp::export]]
Rcpp::List rewire_cpp(arma::vec targetNode,
                      arma::vec index_s,
                      arma::vec index_t,
                      int nattempts, 
                      arma::mat joint_e) {
  GetRNGstate();
  int accepted = 0, p1 = 0, nedge = targetNode.size();
  int e1, e2, temp;
  int s1, s2, t1, t2;
  double u, ratio;
  for (int i = 0; i < nattempts; i ++) {
    e1 = floor(unif_rand() * nedge);
    e2 = floor(unif_rand() * nedge);
    while (e1 == e2) {
      e2 = floor(unif_rand() * nedge);
    }
    s1 = index_s[e1];
    s2 = index_s[e2];
    t1 = index_t[e1];
    t2 = index_t[e2];
    ratio = joint_e(s1, t2) * joint_e(s2, t1) / 
      (joint_e(s1, t1) * joint_e(s2, t2));
    u = unif_rand();
    if (ratio == 1) {
      p1++;
    }
    if (u < ratio) {
      accepted++;
      temp = index_t[e1];
      index_t[e1] = index_t[e2];
      index_t[e2] = temp;
      temp = targetNode[e1];
      targetNode[e1] = targetNode[e2];
      targetNode[e2] = temp;
    }
  }
  PutRNGstate();

  Rcpp::List ret;
  ret["targetNode"] = targetNode;
  ret["accepted"] = accepted;
  ret["index_t"] = index_t;
  ret["p1"] = p1;
  return ret;
}