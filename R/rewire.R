#' @importFrom igraph graph_from_edgelist as_adjacency_matrix
#' @importFrom stats cor
NULL

#' Degree preserving rewiring towards the target joint edge-level distribution.
#'
#' @param edgelist Two column matrix, each row represents a directed edge.
#' @param joint_e Matrix, target joint distribution generated by
#'   wdnet::directed_edge_level_dist().
#' @param nloops Integer, number of loops for nattemtps rewiring attempts.
#' @param nattempts Integer, number of rewiring attempts for each loop. Default
#'   value equals the number of rows of edgelist.
#' @param otherMetrics Logical, whether clutering coefficients, number of
#'   triangles, number of self-loops and number of unique edges are calculated
#'   after each loop.
#'
#' @return Rewired edgelist, number of accepted attempts, four directed
#'   assortativity coefficients and some other metrics after each loop.
#' @export
#'
#' @examples
#' edgelist <- rpanet(30000, control = panet.control(
#'    alpha = 0.3, beta = 0.1, gamma = 0.3, xi = 0.3,
#'    delta_out = 1, delta_in = 1))$edgelist
#' r <- list('out-out' = -0.1, 'out-in' = 0.5, 'in-out' = 0.4, 'in-in' = 0.4)
#' ret1 <- directed_edge_level_dist(edgelist, targetRho = r)
#' ret2 <- directed_rewire(edgelist, joint_e = ret1$joint_e, nloops = 500)
#' ret2 <- directed_rewire(edgelist, joint_e = ret1$joint_e, nloops = 10, otherMetrics = TRUE)
#' 
directed_rewire <- function(edgelist, joint_e, 
                            nloops = 1, nattempts = NA, 
                            otherMetrics = FALSE) {
  if (is.na(nattempts)) nattempts <- nrow(edgelist)
  
  edgelist <- as.matrix(edgelist)
  temp <- range(edgelist)
  sourceNode <- edgelist[, 1]
  targetNode <- edgelist[, 2]
  stopifnot(temp[1] == 1)
  stopifnot(temp[2] == length(unique(c(edgelist))))
  temp <- nodeStrength_cpp(startNode = sourceNode, 
                           endNode = targetNode, 
                           nNodes = temp[2], 
                           weight = 1,
                           weighted = FALSE)
  outd <- temp$outstrength
  ind <- temp$instrength
  
  df_s <- data.frame(type = rownames(joint_e), index = (1:nrow(joint_e)) - 1)
  df_t <- data.frame(type = colnames(joint_e), index = (1:ncol(joint_e)) - 1)
  type_s <- paste0(outd[sourceNode], '-', ind[sourceNode], split = '')
  type_t <- paste0(outd[targetNode], '-', ind[targetNode], split = '')
  
  index_s <- df_s[match(type_s, df_s$type), 'index']
  index_t <- df_t[match(type_t, df_t$type), 'index']
  rm(df_s, df_t, type_s, type_t, temp)
  if (otherMetrics) {
    g <- igraph::graph_from_edgelist(edgelist)
    adj <- igraph::as_adjacency_matrix(g, sparse = TRUE)
    initialCC <- dw_clustcoeff(adj)
  }
  
  ret_rho <- data.frame(Index = 0:nloops, 
                        'out-out' = NA, 
                        'out-in' = NA, 
                        'in-out' = NA, 
                        'in-in' = NA)
  ret_rho[1, 2:5] <- unlist(edge_assort(edgelist))
  
  p1 <- accepted <- 0
  if (otherMetrics) {
    .Metrics <- data.frame(Index = 0:nloops, 
                           numLoops = NA, 
                           uniqueEdges = NA, 
                           totalTriangles = NA, 
                           outTriangles = NA, 
                           inTriangles = NA, 
                           middleTriangles = NA, 
                           cycleTriangles = NA,
                           totalCC = NA, 
                           outCC = NA, 
                           inCC = NA, 
                           middleCC = NA, 
                           cycleCC = NA)
    .Metrics[1, 2:13] <- c(sum(edgelist[, 1] == edgelist[, 2]), 
                           nrow(unique(edgelist)), 
                           sum(initialCC$total$numtriangles), 
                           sum(initialCC$out$numtriangles),
                           sum(initialCC$'in'$numtriangles), 
                           sum(initialCC$middle$numtriangles), 
                           sum(initialCC$cycle$numtriangles), 
                           initialCC$total$globalcc, 
                           initialCC$out$globalcc, 
                           initialCC$'in'$globalcc, 
                           initialCC$middle$globalcc, 
                           initialCC$cycle$globalcc)
  }
  sourceOut <- outd[sourceNode]
  sourceIn <- ind[sourceNode]
  for (i in 2:(nloops + 1)) {
    ret <- directed_rewire_cpp(targetNode, 
                      index_s, index_t, 
                      nattempts, joint_e)
    accepted <- accepted + ret$accepted
    p1 <- p1 + ret$p1
    targetNode <- ret$targetNode
    index_t <- ret$index_t
    rm(ret)
    targetOut <- outd[targetNode]
    targetIn <- ind[targetNode]
    ret_rho[i, 2:5] <- c(
      'out-out' = stats::cor(sourceOut, targetOut),
      'out-in' = stats::cor(sourceOut, targetIn),
      'in-out' = stats::cor(sourceIn, targetOut),
      'in-in' = stats::cor(sourceIn, targetIn))
    if (otherMetrics) {
      edgelist[, 2] <- targetNode
      g <- igraph::graph_from_edgelist(edgelist)
      adj <- igraph::as_adjacency_matrix(g, sparse = TRUE)
      currentCC <- dw_clustcoeff(adj, method = 'Clemente')
      .Metrics[i, 2:13] <- c(sum(edgelist[, 1] == edgelist[, 2]), 
                             nrow(unique(edgelist)), 
                             sum(currentCC$total$numtriangles), 
                             sum(currentCC$out$numtriangles),
                             sum(currentCC$'in'$numtriangles), 
                             sum(currentCC$middle$numtriangles), 
                             sum(currentCC$cycle$numtriangles), 
                             currentCC$total$globalcc, 
                             currentCC$out$globalcc, 
                             currentCC$'in'$globalcc, 
                             currentCC$middle$globalcc, 
                             currentCC$cycle$globalcc)
    }
  }
  colnames(ret_rho) <- c('Index', 'out-out', 
                         'out-in', 'in-out', 
                         'in-in')
  if (otherMetrics) {
    return(list(rho = ret_rho,
                accepted = accepted,
                p1 = p1, otherMetrics = .Metrics,
                edgelist = edgelist))
  }
  edgelist[, 2] <- targetNode
  return(list(rho = ret_rho,
              accepted = accepted,
              p1 = p1,
              edgelist = edgelist))
}

#' Degree preserving rewiring towards the target edge-level distribution.
#'
#' @param edgelist Two column matrix, each row represents a directed edge.
#' @param nloops Integer, number of loops for nattemtps rewiring attempts.
#' @param nattempts Integer, number of rewiring attempts for each loop. Default
#'   value equals the number of rows of edgelist.
#' @param e Matrix, target edge-level distribution generated by
#'   wdnet::undirected_edge_level_dist().
#' @return Rewired edgelist, number of accepted attempts and assortativity
#'   coefficient after each loop.
#' @export
#'
#' @examples
#' set.seed(1234)
#' edgelist <- matrix(sample(1:50, 10000, replace = TRUE), ncol = 2)
#' ret1 <- undirected_edge_level_dist(edgelist)
#' ret2 <- undirected_rewire(edgelist, e = ret1$lbound$e, nloops = 500)
#' ret3 <- undirected_edge_level_dist(edgelist, targetRho = 0.5)
#' ret4 <- undirected_rewire(edgelist, e = ret3$e, nloops = 500)
#' 
undirected_rewire <- function(edgelist, e, 
                              nloops = 1, nattempts = NA) {
  if (is.na(nattempts)) nattempts <- nrow(edgelist)
  
  edgelist <- as.matrix(edgelist)
  temp <- range(edgelist)
  stopifnot(temp[1] == 1)
  stopifnot(temp[2] == length(unique(c(edgelist))))
  degree <- data.frame(table(c(edgelist)))$Freq
  d_df <- data.frame(type = rownames(e), index = (1:nrow(e)) - 1)
  node_s <- edgelist[, 1]
  node_t <- edgelist[, 2]
  index_s <- d_df[match(degree[node_s], d_df$type), 'index']
  index_t <- d_df[match(degree[node_t], d_df$type), 'index']
  rm(d_df, temp)
  ret_rho <- data.frame(Index = 0:nloops, rho = NA)
  ret_rho[1, 2] <- edge_assort(edgelist, directed = FALSE)
  
  p1 <- accepted <- 0
  for (i in 2:(nloops + 1)) {
    ret <- undirected_rewire_cpp(node_s, node_t, 
                      index_s, index_t, 
                      nattempts, e)
    accepted <- accepted + ret$accepted
    p1 <- p1 + ret$p1
    node_s <- ret$node_s
    node_t <- ret$node_t
    index_t <- ret$index_t
    index_s <- ret$index_s
    rm(ret)
    d_node_s <- degree[node_s]
    d_node_t <- degree[node_t]
    ret_rho[i, 2] <- stats::cor(c(d_node_s, d_node_t), c(d_node_t, d_node_s))
  }
  return(list(rho = ret_rho,
              accepted = accepted,
              p1 = p1,
              edgelist = cbind(node_s, node_t)))
}
