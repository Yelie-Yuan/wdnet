#' @importFrom igraph graph_from_adjacency_matrix as_edgelist
#' @importFrom stats cor
NULL

#' Degree preserving rewiring towards the target structure \code{eta}.
#'
#' @param edgelist Two column matrix, each row represents a directed edge.
#' @param eta Matrix, target structure eta generated by
#'   \code{wdnet::directed_joint_dist()}.
#' @param iteration Integer, number of iterations for \code{nattemtps} rewiring attempts.
#' @param nattempts Integer, number of rewiring attempts for each iteration. Default
#'   value equals the number of rows of edgelist.
#' @param edge_scenario Vector, consists of the scenarios of each edge for PA networks.
#'
#' @return Rewired edgelist, percentage of accepted attempts, 
#'   percentage of acceptance at each iteration, and four directed
#'   assortativity coefficients after each iteration.
#' @export
#'
#' @examples
#' set.seed(1234)
#' edgelist <- rpanet(10000, control = panet.control(
#'    alpha = 0.3, beta = 0.1, gamma = 0.3, xi = 0.3,
#'    delta_out = 1, delta_in = 1))$edgelist
#' r <- list("out-out" = -0.1, "out-in" = 0.3, "in-out" = 0.2, "in-in" = 0.1)
#' ret1 <- directed_joint_dist(edgelist, targetRho = r)
#' ret2 <- directed_rewire(edgelist, eta = ret1$eta, iteration = 200)
#' plot(ret2$rho$Iteration, ret2$rho$"out-in")
#' 
directed_rewire <- function(edgelist, eta, 
                            iteration = 1, nattempts = NA, 
                            edge_scenario = NA) {
  if (is.na(nattempts)) nattempts <- nrow(edgelist)
  edgelist <- as.matrix(edgelist)
  temp <- range(edgelist)
  sourceNode <- edgelist[, 1]
  targetNode <- edgelist[, 2]
  stopifnot(temp[1] == 1)
  stopifnot(temp[2] == length(unique(c(edgelist))))
  temp <- nodeStrength_cpp(startNode = sourceNode, 
                           endNode = targetNode, 
                           nNodes = temp[2], 
                           weight = 1,
                           weighted = FALSE)
  outd <- temp$outstrength
  ind <- temp$instrength
  
  df_s <- data.frame(type = rownames(eta), 
                     index = seq_len(nrow(eta)) - 1)
  df_t <- data.frame(type = colnames(eta), 
                     index = seq_len(ncol(eta)) - 1)
  type_s <- paste0(outd[sourceNode], "-", ind[sourceNode], split = "")
  type_t <- paste0(outd[targetNode], "-", ind[targetNode], split = "")
  
  index_s <- df_s[match(type_s, df_s$type), "index"]
  index_t <- df_t[match(type_t, df_t$type), "index"]
  rm(df_s, df_t, type_s, type_t, temp)
  if (is.na(edge_scenario[1])) edge_scenario <- rep(0, nrow(edgelist))
  ret <- directed_rewire_cpp(iteration, nattempts, 
                             outd, ind, sourceNode - 1, 
                             targetNode - 1, 
                             index_s, index_t, 
                             eta, edge_scenario)
  rho <- data.frame("Iteration" = c(0:iteration), 
                    "out-out" = NA, 
                    "out-in" = NA, 
                    "in-out" = NA, 
                    "in-in" = NA)
  rho[1, 2:5] <- unlist(edge_assort(edgelist))
  rho[2:(iteration +1), 2] <- ret$out_out
  rho[2:(iteration +1), 3] <- ret$out_in
  rho[2:(iteration +1), 4] <- ret$in_out
  rho[2:(iteration +1), 5] <- ret$in_in
  ret$accept_scenarios[, 1] <- ret$accept_scenarios[, 1] + 1
  colnames(rho) <- c("Iteration", 
                     "out-out", "out-in", 
                     "in-out", "in-in")
  colnames(ret$accept_scenarios) <- c("Iteration", "Edge1", "Edge2")
  edgelist[, 2] <- ret$targetNode + 1
  return(list(rho = rho,
              edgelist = edgelist, 
              accept = ret$accept_count / iteration / nattempts,
              accept_track = data.frame(Iteration = seq_len(iteration), 
                                        Accept = ret$accept_track / nattempts),
              accept_scenarios = data.frame(ret$accept_scenarios),
              edge_scenario = c(ret$edge_scenario),
              p1 = ret$p1))
}

#' Degree preserving rewiring towards the target structure \code{e}.
#'
#' @param edgelist Two column matrix, each row represents a directed edge.
#' @param iteration Integer, number of iterations for \code{nattemtps} rewiring attempts.
#' @param nattempts Integer, number of rewiring attempts for each iteration. Default
#'   value equals the number of rows of edgelist.
#' @param e Matrix, target structure \code{e} generated by
#'   \code{wdnet::undirected_joint_dist()}.
#' @return Rewired edgelist, percentage of accepted rewiring attempts,
#'   percentage of acceptance at each iteration, 
#'   and assortativity coefficient after each iteration.
#' @export
#'
#' @examples
#' set.seed(1234)
#' mat1 <- matrix(rbinom(10000, 1, 0.3), 100)
#' mat1 <- pmax(mat1, t(mat1))
#' g1 <- igraph::graph_from_adjacency_matrix(mat1)
#' edgelist <- igraph::as_edgelist(g1)
#' ret1 <- undirected_joint_dist(edgelist)
#' ret2 <- undirected_rewire(edgelist, e = ret1$lbound$e, iteration = 500)
#' plot(ret2$rho$Iteration, ret2$rho$rho)
#' ret3 <- undirected_joint_dist(edgelist, targetRho = 0.5)
#' ret4 <- undirected_rewire(edgelist, e = ret3$e, iteration = 500)
#' plot(ret4$rho$Iteration, ret4$rho$rho)
#' 
undirected_rewire <- function(edgelist, e, 
                              iteration = 1, nattempts = NA) {
  if (is.na(nattempts)) nattempts <- nrow(edgelist)
  
  edgelist <- as.matrix(edgelist)
  temp <- range(edgelist)
  stopifnot(temp[1] == 1)
  stopifnot(temp[2] == length(unique(c(edgelist))))
  degree <- data.frame(table(c(edgelist)))$Freq
  d_df <- data.frame(type = rownames(e), index = seq_len(nrow(e)) - 1)
  node1 <- edgelist[, 1]
  node2 <- edgelist[, 2]
  index1 <- d_df[match(degree[node1], d_df$type), "index"]
  index2 <- d_df[match(degree[node2], d_df$type), "index"]
  rm(d_df, temp)
  degree1 <- degree[c(node1, node2)]
  degree2 <- degree[c(node2, node1)]
  ret <- undirected_rewire_cpp(iteration, nattempts, 
                           node1, node2,
                           degree1, degree2,
                           index1, index2,
                           e)
  rm(node1, node2, degree1, degree2, index1, index2)
  rho <- data.frame(Index = c(0:iteration), rho = NA)
  rho[1, 2] <- edge_assort(edgelist, directed = FALSE)
  rho[2:(iteration + 1), 2] <- ret$rho
  colnames(rho) <- c("Iteration", "rho")
  edgelist <- cbind(ret$node1, ret$node2)
  return(list(rho = rho,
              edgelist = edgelist,
              accept = ret$accept_count / iteration / nattempts,
              accept_track = data.frame(Iteration = seq_len(iteration), 
                                        Accept = ret$accept_track / nattempts),
              p1 = ret$p1, 
              degree1 = ret$degree1,
              degree2 = ret$degree2))
}
